#!/usr/bin/env python
########################################################################
#
# diffpy.srfit      by DANSE Diffraction group
#                   Simon J. L. Billinge
#                   (c) 2008 Trustees of the Columbia University
#                   in the City of New York.  All rights reserved.
#
# File coded by:    Chris Farrow
#
# See AUTHORS.txt for a list of people who contributed.
# See LICENSE.txt for license information.
#
########################################################################
"""The Profile class containing the physical and calculated data.

"""

import numpy
import scipy

class Profile(object):
    """Abstract class for one-dimensional data containers.

    Attributes

    _xobs   --  A numpy array of the observed independent variable (default
                0)
    _yobs   --  A numpy array of the observed signal (default 0)
    _dyobs  --  A numpy array of the uncertainty of the observed signal (default
                1, optional)
    _yr     --  The profile over the calculation range (default 0).
    _dyr    --  The uncertainty in the profile over the calculation range
                (default 1).
    _x      --  A numpy array of the calculated independent variable (default
                0)
    _y      --  A numpy array of the calculated signal (default 0)
    _dy     --  A numpy array of the uncertainty of the calculated signal
                (default 1, optional)

    """

    def __init__(self):
        """Initialize the attributes."""
        self._xobs = 0
        self._yobs = 0
        self._dyobs = 1
        self._yr = 0
        self._dyr = 1
        self._x = 0
        self._y = 0
        self._dy = 1

    def setObservedProfile(self, xobs, yobs, uobs = None):
        """Set the observed profile.

        Arguments
        xobs    --  Numpy array of the independent variable
        yobs    --  Numpy array of the observed signal
        uobs    --  Numpy array of the uncertainty in the observed signal, or
                    None. If uobs is None (default), it is assumed that the
                    uncertainty in the signal is 1, in units appropriate for the
                    signal.

        """
        self._xobs = numpy.asarray(xobs, dtype=float)
        self._yobs = numpy.asarray(yobs, dtype=float)
        if uobs is not None:
            self._uobs = numpy.asarray(uobs, dtype=float)
        else:
            self._uobs = numpy.ones(len(xobs), dtype=float)

        return

    def getObservedProfile(self):
        """Get the data arrays.

        Returns (xobs, yobs, uobs) where xobs is an array containing the
        independent variable, yobs is an array containing the observed signal
        and uobs is the uncertainty in yobs, or None.
        """
        return (self._xobs, self._yobs, self._uobs)

    def getRangedProfile(self):
        """Get the data arrays over the calculation range.

        Returns (xr, yr, ur) where xr is an array containing the
        independent variable, yr is an array containing the observed signal
        and uobs is the uncertainty in yr, all over the calculation range.
        """
        return (self._x, self._yr, self._dyr)

    def getCalculatedProfile(self):
        """Get the calculated profile.

        The profile is generated by a Calculator instance.
        """
        return (self._x, self._y, self._dy)

    def setCalculationRange(self, xmin, xmax, dx = 0):
        """Set the calculation range

        Arguments
        xmin    --  The minimum value of the independent variable (inclusive).
        xmax    --  The maximum value of the independent variable (exclusive).
        dx      --  The sample spacing in the independent variable. If dx is 0,
                    and there is an observed profile, then dx is taken from
                    that.

        raises ValueError if xmin > xmax
        raises ValueError if dx > xmax-xmin
        raises ValueError if dx < 0
        raises ValueError if dx <= 0 and no obseved profile has been loaded.

        """
        xmin = float(xmin)
        xmax = float(xmax)
        dx = float(dx)
        if xmin > xmax:
            raise ValueError("xmax must be greater than xmin")
        if dx > xmax - xmin:
            raise ValueError("dx must be less than xmax-xmin")
        if dx < 0:
            raise ValueError("dx must be positive")
        if dx == 0 and self._xobs == 0:
            raise ValueError("Cannot determine dx")

        if dx == 0:
            dx = self._xobs[1] - self._xobs[0]

        self.setCalculationPoints(numpy.arange(xmin, xmax, dx))
        return

    def setCalculationPoints(self, x):
        """Set the calculation range with an array.

        Arguments
        x   --  A non-empty numpy array containing the calculation points.

        """
        self._x = numpy.asarray(x)
        self._yr = rebinArray(self._yobs, self._xobs, self._xr)
        self._dyr = rebinArray(self._dyobs, self._xobs, self._xr)
        return

# End class Profile

def rebinArray(A, xold, xnew):
    """Rebin the an array by interpolating over the new x range.

    Arguments:
    A       --  Array to interpolate
    xold    --  Old sampling array
    xnew    --  New sampling array

    This uses cubic spline interpolation.
    
    Returns: A new array over the new sampling array.
    """
    from scipy.interpolate import splrep, splev
    finterp = splrep(xold, A, s=0)
    return splev(xnew, finterp, der=0)

__id__ = "$Id$"

if __name__ == "__main__":
    # Check to see if everything imports correctly
    pass
